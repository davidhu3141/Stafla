
<html>

<head>

	<meta http-equiv="content-type" content="text/html" charset="utf-8" />

	<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
	<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>

	<link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700' rel='stylesheet' type='text/css'>
	<link rel=stylesheet type="text/css" href="src/article.css">

	<link rel="stylesheet" href="src/highlight/styles/default.css">
	<script src="src/highlight/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>

</head>

	<body>

	<div class="article">
<h1 id="物件導向基礎語法-object-oriented-programming-basic-semantics">物件導向基礎語法 Object-Oriented Programming Basic Semantics</h1>

<p>因為觀念大家都差不多懂了，所以重點是學習物件導向的哲學，了解「這些語法解決了什麼工程問題？」</p>

<p>所謂工程問題，目前可以理解為「大型程式開發與維護」遇到的問題。 <br>
這種問題主要有兩大類：</p>

<blockquote>
  <ul>
  <li>程式碼的維護。怎樣的程式架構難以維護、難以除錯、難以 Code Reuse？客戶需求改變時，程式會需要完全重寫嗎？</li>
  <li>人員的分工。怎麼讓多人工作時彼此的程式可以銜接？誰可以改誰的 Code？權責分明是放諸四海皆準的守則。</li>
  </ul>
</blockquote>

<p>以下的筆記以 Java 語法為準</p>

<p><div class="toc">
<ul>
<li><a href="#物件導向基礎語法-object-oriented-programming-basic-semantics">物件導向基礎語法 Object-Oriented Programming Basic Semantics</a><ul>
<li><a href="#一類別與物件">一、類別與物件</a></li>
<li><a href="#二屬性與方法">二、屬性與方法</a><ul>
<li><a href="#屬性-field">屬性 Field</a></li>
<li><a href="#方法-method">方法 Method</a><ul>
<li><a href="#建構子">建構子</a></li>
<li><a href="#finalize">finalize</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#三封裝-encapsulation">三、封裝 Encapsulation</a><ul>
<li><a href="#公有與私有">公有與私有</a></li>
<li><a href="#在-eclipse-中快速封裝">在 Eclipse 中快速封裝:</a></li>
<li><a href="#這樣解決了什麼工程問題">這樣解決了什麼工程問題</a></li>
</ul>
</li>
<li><a href="#四靜態屬性與方法-static-fields-and-methods">四、靜態屬性與方法 Static Fields and Methods</a><ul>
<li><a href="#舉例">舉例</a><ul>
<li><a href="#例-1這個屬性是誰的">例 1：這個屬性是誰的？</a></li>
<li><a href="#例-2常見的例子無關物件的函數">例 2：常見的例子，無關物件的函數</a></li>
<li><a href="#例-3有關初始化的語法">例 3：有關初始化的語法</a></li>
<li><a href="#例-4常犯的錯誤">例 4：常犯的錯誤</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#五繼承-inherit">五、繼承 Inherit</a><ul>
<li><a href="#使用時機">使用時機</a><ul>
<li><a href="#subset-必要條件">Subset （必要條件）</a></li>
<li><a href="#code-reuse">Code Reuse</a></li>
<li><a href="#extend-class-functionality">Extend Class Functionality</a></li>
</ul>
</li>
<li><a href="#protected-指示字">Protected 指示字</a></li>
<li><a href="#override-annotation">Override Annotation</a></li>
<li><a href="#誤用繼承">誤用繼承</a><ul>
<li><a href="#例一子類別改變父類別的預期行為">例一：子類別改變父類別的預期行為</a></li>
<li><a href="#例二抽象意義上不符合不應該繼承">例二：抽象意義上不符合，不應該繼承</a></li>
<li><a href="#例三背叛父類別">例三：背叛父類別</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#七抽象類別-abstract-class">七、抽象類別 Abstract Class</a><ul>
<li><a href="#使用時機-1">使用時機</a><ul>
<li><a href="#例profiledatabase">例：ProfileDatabase</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#八介面-interface">八、介面 Interface</a><ul>
<li><a href="#關於語法">關於語法</a></li>
<li><a href="#使用時機-2">使用時機</a><ul>
<li><a href="#例實作-comparable-介面">例：實作 Comparable 介面</a></li>
</ul>
</li>
<li><a href="#java-官方建議的使用時機">Java 官方建議的使用時機</a><ul>
<li><a href="#以下情況建議使用抽象類別">以下情況建議使用抽象類別</a></li>
<li><a href="#以下情況建議使用介面">以下情況建議使用介面</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</p>

<h2 id="一類別與物件">一、類別與物件</h2>

<p>不需要多說，類別是抽象概念（或型別）的定義，物件是依照概念而建立的具象實體（變數）。</p>



<h2 id="二屬性與方法">二、屬性與方法</h2>



<h3 id="屬性-field">屬性 Field</h3>

<p>這裡就不廢話了</p>



<h3 id="方法-method">方法 Method</h3>

<p>這裡為特殊的方法 – 建構子與 finalize – 做補充</p>



<h4 id="建構子">建構子</h4>

<ul>
<li>可以是私有的</li>
<li>物件的生命始於建構子，止於 GC</li>
</ul>



<h4 id="finalize">finalize</h4>

<ul>
<li>finalize 會在 GC 時被呼叫，並不同於 C++ 的解構子，因為我們不需要自己釋放記憶體</li>
<li>我們不應該主動呼叫 finalize（那是 GC 的事，我們也不應該臆測 GC 的行為，<strong>權責分明</strong>）</li>
</ul>



<h2 id="三封裝-encapsulation">三、封裝 Encapsulation</h2>

<ul>
<li>抽象化的第一步</li>
<li>隱藏所有實作訊息，不只是寫 getter 與 setter</li>
</ul>



<h3 id="公有與私有">公有與私有</h3>

<p>大家應該都用習慣了XD <br>
這些語法正是為封裝而生。</p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j;
    <span class="hljs-keyword">int</span> k; <span class="hljs-comment">// package scope</span>
}</code></pre>

<h3 id="在-eclipse-中快速封裝">在 Eclipse 中快速封裝:</h3>

<blockquote>
  <p>對一個 field 右鍵 &gt; Refactor &gt; Encapsulation</p>
</blockquote>



<h3 id="這樣解決了什麼工程問題">這樣解決了什麼工程問題</h3>

<p>沒封裝好的例子：</p>



<pre class="prettyprint"><code class="language-java hljs ">class Square {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEdgeLengthFromArea</span>(<span class="hljs-keyword">double</span> area){
        <span class="hljs-comment">/* 請各位開發者輸入非負的數，否則會噴 */</span>
        <span class="hljs-keyword">return</span> Math.sqrt(area);
    }
}</code></pre>

<p>發現了嗎？他不應該要求所有上層開發者來看他的 code 與註解。當 code 越來越大，上層開發者會有很多地雷要閃。</p>

<p>修正：</p>

<pre class="prettyprint"><code class="language-java hljs ">class Square {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> area;
    <span class="hljs-keyword">public</span> <span class="hljs-title">Square</span>(<span class="hljs-keyword">double</span> area) <span class="hljs-keyword">throws</span> IllegalArgumentException {
        <span class="hljs-keyword">if</span> (area &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>.area = area;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Area should be non-negative"</span>);
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getEdgeLengthFromArea</span>(<span class="hljs-keyword">double</span> area){
        <span class="hljs-keyword">return</span> Math.sqrt(area);
    }
}</code></pre>

<h2 id="四靜態屬性與方法-static-fields-and-methods">四、靜態屬性與方法 Static Fields and Methods</h2>

<ul>
<li>靜態屬性是關於類別本身的。所有 new 出來的物件、所有的 Thread 、都共用這一個變數。</li>
<li>非靜態屬性是物件的。每個 new 出來的物件都有自己個別的屬性</li>
<li>靜態方法不能存取非靜態屬性（他也不知道要從哪個 Object 取）</li>
</ul>



<h3 id="舉例">舉例</h3>

<h4 id="例-1這個屬性是誰的">例 1：這個屬性是誰的？</h4>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AESCipher</span>{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> BLOCKLEN = <span class="hljs-number">16</span>; <span class="hljs-comment">// 跟 cipher 的抽象定義有關，不會因個別的 cipher 而變</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] key; <span class="hljs-comment">// 每個 cipher 要用的 key 都不一樣</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title">AESCipher</span>(<span class="hljs-keyword">byte</span>[] key){...};
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] <span class="hljs-title">encrypt</span>(<span class="hljs-keyword">byte</span>[] data){...}
}
...
AESCipher cipher = <span class="hljs-keyword">new</span> AESCipher(key);</code></pre>

<ul>
<li><code>print(cipher.BLOCKLEN)? // 不建議</code></li>
<li><code>print(AESCipher.BLOCKLEN) // 建議</code></li>
</ul>

<h4 id="例-2常見的例子無關物件的函數">例 2：常見的例子，無關物件的函數</h4>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Math</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">sin</span>(<span class="hljs-keyword">double</span> x){...}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">log</span>(<span class="hljs-keyword">double</span> x){...}
}</code></pre>

<h4 id="例-3有關初始化的語法">例 3：有關初始化的語法</h4>

<p>動態的初始 Assignment 在建構子 <br>
靜態的初始 Assignment 在 ClassLoader</p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span>{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">static</span> {
        i = <span class="hljs-number">10</span>;
    }
}</code></pre>

<p>等同於以下的 <strong>compiler sugar</strong></p>

<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">foo</span>{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;
}</code></pre>

<h4 id="例-4常犯的錯誤">例 4：常犯的錯誤</h4>

<blockquote>
  <p>原文出處：<a href="http://www.oreilly.com.tw/column_sleepless2.php?id=part24">http://www.oreilly.com.tw/column_sleepless2.php?id=part24</a></p>
</blockquote>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> {</span>
　　<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton obj = <span class="hljs-keyword">new</span> Singleton();
　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter1;
　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter2 = <span class="hljs-number">0</span>;
　　<span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>() {
　　 　counter1++;
　　 　counter2++;
   }
　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>() {
　　 　<span class="hljs-keyword">return</span> obj;
　　}
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMain</span> {</span>
　　<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) {
　　　Singleton obj = Singleton.getInstance();
　　　System.out.println(<span class="hljs-string">"obj.counter1=="</span>+obj.counter1);
　　　System.out.println(<span class="hljs-string">"obj.counter2=="</span>+obj.counter2);
　　}
}</code></pre>

<p>沒有初始化的 counter1 初始值應該也是零，但執行結果卻會與 counter2 不同</p>

<pre class="prettyprint"><code class="language-java hljs ">obj.counter1==<span class="hljs-number">1</span>
obj.counter2==<span class="hljs-number">0</span></code></pre>

<p>請從<strong>初始化乃是 compiler sugar </strong>的角度去想</p>

<h2 id="五繼承-inherit">五、繼承 Inherit</h2>

<p><code>extends</code>關鍵字</p>



<h3 id="使用時機">使用時機</h3>



<h4 id="subset-必要條件">Subset （必要條件）</h4>

<blockquote>
  <p><code>ObjectInputStream</code> <strong>is an</strong> <code>Inputstream</code> <br>
  <code>AESCipher</code> <strong>is a</strong> <code>Cipher</code> <br>
  <code>DESCipher</code> <strong>is a</strong> <code>Cipher</code></p>
</blockquote>



<h4 id="code-reuse">Code Reuse</h4>

<p>不應為了 code reuse 而盲目使用繼承。要注意必要條件</p>



<h4 id="extend-class-functionality">Extend Class Functionality</h4>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileSaver</span>{</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span>(Profile pf, File f){
        ...
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BetterProfileSaver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProfileSaver</span>{</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span>(Profile pf, File file){
        <span class="hljs-keyword">super</span>.save(pf, file);                          <span class="hljs-comment">// reuse</span>
        print(<span class="hljs-string">"Success"</span>);
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveEncryptly</span>(Profile pf, File file){  <span class="hljs-comment">// extend</span>
        save(AES.encrypt(pf), file);
    }
}</code></pre>

<h3 id="protected-指示字">Protected 指示字</h3>

<ul>
<li>只有自己與子類別可以存取。</li>
<li>子類別是父類別的擴充，可能需要父類別的權限，所以設計此語法。</li>
</ul>



<h3 id="override-annotation">Override Annotation</h3>

<ul>
<li>覆寫父類別方法時可以使用</li>
<li>不加也可以，但是當拼錯覆類別方法名稱的時候加了很有用</li>
<li>關於 Annotation 會在 Java 章節介紹</li>
</ul>



<h3 id="誤用繼承">誤用繼承</h3>



<h4 id="例一子類別改變父類別的預期行為">例一：子類別改變父類別的預期行為</h4>

<p>誇張一點的例子：</p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span>(){
        <span class="hljs-comment">/* sorting */</span>
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArrayList</span> {</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span>(){
        deleteAllElements();
    }
}</code></pre>

<p>總之，不要混淆使用你 code 的人</p>

<h4 id="例二抽象意義上不符合不應該繼承">例二：抽象意義上不符合，不應該繼承</h4>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Profile</span> {</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">byte</span>[] ID;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">byte</span>[] PK;
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserData</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Profile</span> {</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">byte</span>[] phoneNum;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">char</span> bloodType;
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> age;
    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>(){
        <span class="hljs-keyword">return</span> <span class="hljs-string">""</span> + ID + PK + phoneNum + bloodType + age;
    }
}
...
UserData user = <span class="hljs-keyword">new</span> UserData()</code></pre>

<p>呼叫會變這樣</p>

<pre class="prettyprint"><code class="language-java hljs ">user.toString() <span class="hljs-comment">// 的確是可以印出來</span>
AuthSocketClient c = <span class="hljs-keyword">new</span> AuthSocketClient(user); <span class="hljs-comment">// 這樣變成意義不明</span></code></pre>

<p>要保持繼承中 <strong>is a</strong> 的概念</p>

<h4 id="例三背叛父類別">例三：背叛父類別</h4>

<p>或是為了揭露父類別特地去繼承</p>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GuessNumber</span> {</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> answer;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">guess</span>(<span class="hljs-keyword">int</span> quest){
        <span class="hljs-keyword">return</span> quest == answer;
    }
}
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">revealGuessNumber</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAnswer</span>(){ <span class="hljs-keyword">return</span> answer; }
}</code></pre>

<p>Java 提供物件導向的語法，但語法並不是重點，遵守規則才是。</p>

<h2 id="七抽象類別-abstract-class">七、抽象類別 Abstract Class</h2>

<ul>
<li>定義類別的行為，卻沒有完整的實作，用來當作別人的父類別</li>
<li>子類別除了必須實作抽象方法之外，還必須在建構子呼叫抽象類別的建構子</li>
</ul>



<h3 id="使用時機-1">使用時機</h3>

<ul>
<li>用來分開定義與實作</li>
</ul>

<blockquote>
  <ul>
  <li>例如<code>List</code>、<code>Set</code>等容器只有定義呼叫方法，實際上再用<code>ArrayList</code>與<code>HashSet</code>等技術來實作</li>
  <li>可以視為<strong>分工</strong>的界線</li>
  </ul>
</blockquote>

<ul>
<li>仍然蘊含有 <strong>is a</strong> 關係，這是和<a href="#八介面-interface">介面</a>最大的不同</li>
</ul>



<h4 id="例profiledatabase">例：ProfileDatabase</h4>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProfileDatabase</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title">ProfileDatabase</span>(){
        <span class="hljs-keyword">if</span>(!existsTable()) createTable();
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> bool <span class="hljs-title">existsTable</span>();
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createTable</span>();
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertProfile</span>(Profile pf);
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryProfile</span>(String ID);
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HbaseProfileDatabase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ProfileDatabase</span> {</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title">HbaseProfileDatabase</span>(){
        <span class="hljs-keyword">super</span>(); <span class="hljs-comment">// 這裡是要呼叫，不是覆寫</span>
    }
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> bool <span class="hljs-title">existsTable</span>(){...}
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createTable</span>(){...}
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertProfile</span>(Profile pf){...}
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryProfile</span>(String ID){...}
}</code></pre>

<h2 id="八介面-interface">八、介面 Interface</h2>



<h3 id="關於語法">關於語法</h3>

<ul>
<li>介面中的屬性只能是<code>static</code>且<code>final</code>的，就算沒加這些指示字也一樣</li>
</ul>



<h3 id="使用時機-2">使用時機</h3>

<ul>
<li>宣告<strong>行為</strong>：實作的人要有這個函數可以呼叫 <br>
<ul><li><code>Runnable</code>: should implement <code>public void run()</code></li>
<li><code>Comparable</code>: should implement <code>public int compareTo()</code>. Think of <strong>Sorting</strong></li></ul></li>
</ul>



<h4 id="例實作-comparable-介面">例：實作 <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort%28java.util.List%29">Comparable</a> 介面</h4>

<blockquote>
  <p><code>Collections :: sort(List&lt;? extends Comparable&gt;)</code></p>
</blockquote>



<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> Profile implements Comparable&lt;Profile&gt; {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ID;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> PK;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span>(Profile pf){
        <span class="hljs-keyword">if</span>     (pf.ID &gt; <span class="hljs-keyword">this</span>.ID) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pf.ID &lt; <span class="hljs-keyword">this</span>.ID) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
}

List&lt;Profile&gt; pflist = ...;
Collections.sort(pflist);
</code></pre>

<ul>
<li>也可作為<strong>分工</strong>的界線</li>
<li>與抽象類別相像。如果一定要由某類特定的類別來實作，則使用抽象類別比較好</li>
</ul>

<h3 id="java-官方建議的使用時機"><a href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html#abstact_classes_compared_to_interfaces">Java 官方</a>建議的使用時機</h3>



<h4 id="以下情況建議使用抽象類別">以下情況建議使用抽象類別</h4>

<ul>
<li>幾個緊密關聯的類別之間，想要使用同一些函數（就是關於繼承的 Code Reuse）</li>
<li>這些子類別的屬性或方法都雷同，只是實作不同而已 <br>
，所以如果想要宣告非<code>static</code>或是非<code>final</code>的屬性則需要使用抽象類別</li>
</ul>



<h4 id="以下情況建議使用介面">以下情況建議使用介面</h4>

<ul>
<li>想要讓幾個無關的類別，都提供你想要的函數</li>
<li>你預期某些特定類別要提供這個方法，但還不知道要由誰來寫。</li>
<li>模擬多型</li>
</ul>	</div>

</body>

</html>
